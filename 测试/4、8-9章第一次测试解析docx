# JS一期第四次测试（定时器、数组与字符串方法）

1.下面结果i是多少？（）

```
for(var i=0;i<5;i++){
    setTimeout(function(){
        console.log(i);
    },500)
}
A.0,1,2,3,4   B.5,5,5,5,5  C. 5  D. 1
答案：（B）
```

解析：for循环执行完毕后，定时器内函数才会执行，定时器是异步执行的，所以打印的是for执行后i的最终结果值。



2.下面结果i是多少？（）

```
for(var i = 0; i < 5; i++) {
     setTimeout(function(i) {
         return function() {
             console.log(i);
         };
     }(i), i * 1000);
}
A.0,1,2,3,4   B.5,5,5,5,5  C. 5  D. 1
答案：（A）
```

解析：这个定时器中的打印i，是调用函数时传的参数值，所以每调用一次，就传入一个新的i值，这样定时器每次执行都会打印当时传入给它的i值。（相当于形成一个闭包，将i值存在了闭包函数内）

3.下面结果为（）

```
var a = 10;
setTimeout(function(){
    a = 20;
},50);
console.log(a);
A:10  B:20
答案:（a）
```

解析：定时器执行是在50ms之后，而打印时定时器还没有开始执行，所以打印的是10；



4.下列对于时间对象描述错误的是？

```
A. getFullYear() 获取当前年份
B. getMonth() 获取当前月份
C. getDate() 获取当前日
D. getHour() 获取当前小时

答案：D
```

解析：获取小时方式：getHours();



5.下面的描述中不正确的是：（）

```
A:arguments 中保存了实际传入函数内的所有参数。
B:return 只能在函数内部使用。
C:setInterval(fn1,1000) 只会调用一次 fn1。
D:Date 对象的 getMonth() 获取到的值比实际月份小1。
答案:（C）
```

解析：setInterval是间隔定时器，所以会每隔1秒调用一次fn1

6.let arr = [1,2,3,4]; 

console.log(arr.join() )

结果是多少？

```
A:'1234' 
B:'1,2,3,4'
C:'[1,2,3,4]' 
D:[1,2,3,4]
答案：（B）
```

解析：join功能是将数组以参数为分隔符，连接成一个新的字符串并返回（默认会以逗号为分隔符）。

​			在此arr.join() 没有传入参数，所以默认会使用逗号做为分隔符。



7.下面关于数组的描述正确的是：（）

```
A:数组的 length 既可以获取，也可以修改。
B:调用 pop() 方法，不会修改原数组中的值。
C:shift() 方法的返回值是新数组的长度。
D:调用 concat() 方法，会修改原数组的值。
答案：（A）
```

解析：A：数组的length属性是可以修改的，例如：arr.length=0; 就会将数组清空

B：pop()方法是删除数组中最后一个值，所以会修改原数组，返回值是所删除的数据本身

C：shift()方法是删除数组中第一个值，同样会修改原数组，返回值是所删除的数据本身

D：concat()方法是合并数组，并且不更改原数组，返回值是一个合并后的新数组

​		

8.以下代码运行后，arr的结果为：（）arr2的结果为：（） 

```
var arr = [1,2]; 
var arr2 = arr.concat(); 
arr2.push( arr.splice(1,0) );
A:[1,2],[1,2,[]]       
B:[1,2],[1,2,[2]]
C:[1,2],[1,2]  
D:[1,2,[]],[1,2,3]
答案：A
```

解析：

arr的初始值是[1,2];

arr2是arr合并一个[]的新数组，所以也是[1,2]

arr2.push( arr.splice(1,0) ); 分2步去看：

1. arr.splice(1,0) 本身没有影响到元素组的值，所以arr还是[1,2];
2. arr.splice(1,0) 的返回值是截取后的新数组，但这个参数表明：从第1个值开始截取0个值，所以返回值是[]（空数组）； 所以arr2向后添加一个[]；所以arr2最终值是[1,2,[]];



9.下列代码将会输出

```
var data = {a: 1, b: 2, c: 3, d: 4}; 
var arr=Object.keys(data).filter(function(key) { return data[key]>2;}) 
console.log(arr);

A. [3,4]
B. ['c','d']
C. {c:3,d:4}
D. [{c:3,d:4}]

答案：B
```

解析：

​	Object.keys(data) 方法返回值是对象下的一组属性名（key值）；filter()方法是根据回调函数的条件，返回true或false（true即保留数组中对应值，否则就不保留）

可以分2步看：

1. Object.keys(data)  =>   ['a','b','c','d'];

 	2. ['a','b','c','d'].filter(function(key){return data[key]>2}) ；   filter内传入函数的参数key，就是'a'/'b'/'c'/'d' ;即最终返回 data对象下val大于2的值为true； 所以最终通过条件的是 'c' 和 'd'; （返回形式是数组形式）；



10.以下代码执行后， arr 的值是：（）

```
var arr=[{a:1},{}];
arr.forEach(function(item,idx){
    item.b=idx;
});

A. [{a:1},{}]
B. [{a:1,b:0},{b:1}]
C. [{a:1,b:1},{b:1}]
D. [{a:!,b:0},{b:0}]

答案：B
```

解析：

​	forEach循环数组，参数item代表每次循环的值（第一次{a:1}，第二次是{}），idx代表每次循环的下标（第一次是0，第二次是1）；

​	在循环当中，item.b=idx； 相当于给每一个循环到的对象添加一个b属性，值为当前循环的下标值；（第一次b:0，第二次b:1）；所以最后的结果是 [{a:1,b:0},{b:1}]





